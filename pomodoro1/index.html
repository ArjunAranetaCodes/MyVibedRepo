<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#7b57ff" />
<link rel="manifest" href="manifest.json" />
<title>Liquid Glass</title>
<style>
  html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0f14; }
  svg { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
  /* Optional film softness */
  .grain { position: fixed; inset: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.05; mix-blend-mode: soft-light; }
  
  /* Menu styles */
  .menu { position: fixed; top: 14px; left: 14px; z-index: 20; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .menu-button { background: rgba(0, 0, 0, 0.25); border: 1px solid rgba(255, 255, 255, 0.1); color: #e8f6ff; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600; letter-spacing: 0.04em; font-size: 14px; backdrop-filter: blur(10px); }
  .menu-button:hover { background: rgba(0, 0, 0, 0.4); border-color: rgba(255, 255, 255, 0.2); }
  .menu-items { position: absolute; top: 100%; left: 0; margin-top: 4px; background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 4px; min-width: 160px; backdrop-filter: blur(10px); display: none; }
  .menu-items.open { display: block; }
  .menu-item { color: #e8f6ff; padding: 10px 12px; cursor: pointer; border-radius: 6px; display: flex; align-items: center; gap: 8px; font-size: 14px; position: relative; }
  .menu-item:hover { background: rgba(255, 255, 255, 0.1); }
  .menu-item-icon { font-size: 18px; }
  .submenu { position: absolute; left: 100%; top: 0; margin-left: 4px; background: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 12px; min-width: 180px; backdrop-filter: blur(10px); display: none; }
  .menu-item:hover .submenu { display: block; }
  .submenu-label { color: #e8f6ff; font-size: 12px; margin-bottom: 4px; display: block; }
  .submenu-input { width: 100%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 6px 8px; color: #e8f6ff; font-size: 14px; box-sizing: border-box; margin-bottom: 8px; }
  .submenu-input:focus { outline: none; border-color: rgba(255, 255, 255, 0.4); background: rgba(255, 255, 255, 0.15); }
  .submenu-input::placeholder { color: rgba(232, 246, 255, 0.5); }
  .submenu-button { width: 100%; background: rgba(123, 87, 255, 0.6); border: 1px solid rgba(123, 87, 255, 0.8); border-radius: 6px; padding: 8px; color: #e8f6ff; font-size: 14px; font-weight: 600; cursor: pointer; margin-top: 4px; }
  .submenu-button:hover { background: rgba(123, 87, 255, 0.8); }
  /* Force black dropdown menu and selection background */
  select.submenu-input { background: #000000 !important; color: #e8f6ff; }
  #backgroundType option, #pomodoroBackgroundType option { background: #000000; color: #e8f6ff; }
  
  /* Pause/Play button */
  .timer-controls { position: fixed; top: 70%; left: 50%; transform: translate(-50%, -50%); z-index: 15; display: flex; align-items: center; gap: 20px; }
  .pause-play-btn { width: 80px; height: 80px; border-radius: 50%; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(255, 255, 255, 0.3); color: #ffffff; font-size: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.3s ease; line-height: 1; padding: 0;  padding-bottom: 2px;  text-align: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3); }
  .pause-play-btn:hover { background: rgba(0, 0, 0, 0.7); border-color: rgba(255, 255, 255, 0.5); transform: scale(1.1); }
  .mode-switch-btn { width: 80px; height: 80px; border-radius: 50%; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(255, 255, 255, 0.3); color: #ffffff; font-size: 24px; cursor: pointer; display: none; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.3s ease; line-height: 1; padding: 0; text-align: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3); }
  .mode-switch-btn:hover { background: rgba(0, 0, 0, 0.7); border-color: rgba(255, 255, 255, 0.5); transform: scale(1.1); }
  .mode-switch-btn.visible { display: flex; }
  .foreground-toggle-btn { width: 80px; height: 80px; border-radius: 50%; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(255, 255, 255, 0.3); color: #ffffff; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.3s ease; line-height: 1; padding: 0; text-align: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3); }
  .foreground-toggle-btn:hover { background: rgba(0, 0, 0, 0.7); border-color: rgba(255, 255, 255, 0.5); transform: scale(1.1); }
  
  /* Foreground widget styles */
  .foreground-widget { position: fixed; bottom: 20px; right: 20px; width: 280px; background: rgba(20, 20, 25, 0.95); border-radius: 16px; padding: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); z-index: 100; display: none; }
  .foreground-widget.active { display: block; }
  .foreground-widget-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
  .foreground-widget-title { color: rgba(255, 255, 255, 0.7); font-size: 12px; font-weight: 500; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .foreground-widget-close { background: none; border: none; color: rgba(255, 255, 255, 0.5); font-size: 18px; cursor: pointer; padding: 0; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; }
  .foreground-widget-close:hover { color: rgba(255, 255, 255, 0.8); }
  .foreground-widget-time { color: #ffffff; font-size: 48px; font-weight: 700; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; text-align: center; margin-bottom: 16px; letter-spacing: 0.02em; }
  .foreground-widget-controls { display: flex; gap: 8px; justify-content: center; }
  .foreground-widget-btn { flex: 1; background: rgba(123, 87, 255, 0.8); border: none; border-radius: 8px; padding: 10px; color: #ffffff; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .foreground-widget-btn:hover { background: rgba(123, 87, 255, 1); }
  .foreground-widget-btn.secondary { background: rgba(255, 255, 255, 0.1); }
  .foreground-widget-btn.secondary:hover { background: rgba(255, 255, 255, 0.2); }
  
  /* Hide fullscreen timer when in foreground mode */
  body.foreground-mode #timer { display: none; }
  body.foreground-mode .timer-controls { display: none; }
</style>
</head>
<body>
  <div class="menu">
    <button class="menu-button" id="menuButton">‚ò∞ Menu</button>
    <div class="menu-items" id="menuItems">
      <div class="menu-item" style="display: none;">
        <span class="menu-item-icon">‚è±Ô∏è</span>
        <span>Timer Settings</span>
        <div class="submenu">
          <label class="submenu-label" for="timerInput">Timer (minutes)</label>
          <input type="text" id="timerInput" class="submenu-input" placeholder="25" />
          <label class="submenu-label" for="backgroundType">Background</label>
          <select id="backgroundType" class="submenu-input" style="margin-bottom: 8px;">
            <option value="liquid-glass">Liquid Glass</option>
            <option value="solid-color">Solid Color</option>
          </select>
          <div id="colorPickerContainer" style="display: none; margin-bottom: 8px;">
            <input type="color" id="backgroundColorPicker" class="submenu-input" value="#0b0f14" style="height: 40px; cursor: pointer; padding: 4px;" />
          </div>
          <button class="submenu-button" id="applyTimerBtn">Apply</button>
        </div>
      </div>
      <div class="menu-item">
        <span class="menu-item-icon">üéµ</span>
        <span>Music</span>
        <div class="submenu">
          <label class="submenu-label" for="musicMuteToggle">Mute Music</label>
          <button class="submenu-button" id="musicMuteToggle" style="margin-bottom: 8px;">Unmute</button>
          <label class="submenu-label" for="musicPlayMode">Play Mode</label>
          <select id="musicPlayMode" class="submenu-input" style="margin-bottom: 8px;">
            <option value="auto">Auto-play with Timer</option>
            <option value="manual">Manual Control</option>
          </select>
          <label class="submenu-label" for="musicSelect">Select Song</label>
          <select id="musicSelect" class="submenu-input" style="margin-bottom: 8px;">
            <option value="0">Dusty Loops 1</option>
            <option value="1">Dusty Loops 2</option>
          </select>
          <button class="submenu-button" id="playSelectedMusic">Play Selected</button>
        </div>
      </div>
      <div class="menu-item">
        <span class="menu-item-icon">üçÖ</span>
        <span>Pomodoro</span>
        <div class="submenu">
          <label class="submenu-label" for="focusInput">Focus (minutes)</label>
          <input type="text" id="focusInput" class="submenu-input" placeholder="25" />
          <label class="submenu-label" for="breakInput">Break (minutes)</label>
          <input type="text" id="breakInput" class="submenu-input" placeholder="5" />
          <label class="submenu-label" for="pomodoroBackgroundType">Background</label>
          <select id="pomodoroBackgroundType" class="submenu-input" style="margin-bottom: 8px;">
            <option value="liquid-glass">Liquid Glass</option>
            <option value="solid-color">Solid Color</option>
          </select>
          <div id="pomodoroColorPickerContainer" style="display: none;">
            <label class="submenu-label" for="focusColorPicker">Focus Color</label>
            <div style="display:flex; gap:8px; align-items:center; margin-bottom: 8px;">
              <input type="color" id="focusColorPicker" class="submenu-input" value="#0b0f14" style="height: 40px; cursor: pointer; padding: 4px; margin: 0;" />
              <button class="submenu-button" id="setFocusColorBtn" style="width:auto; white-space:nowrap; margin: 0;">Set</button>
            </div>
            <label class="submenu-label" for="breakColorPicker">Break Color</label>
            <div style="display:flex; gap:8px; align-items:center;">
              <input type="color" id="breakColorPicker" class="submenu-input" value="#1a2f3a" style="height: 40px; cursor: pointer; padding: 4px; margin: 0;" />
              <button class="submenu-button" id="setBreakColorBtn" style="width:auto; white-space:nowrap; margin: 0;">Set</button>
            </div>
          </div>
          <button class="submenu-button" id="applyPomodoroBtn">Apply</button>
        </div>
      </div>
    </div>
  </div>
  <div id="timer" style="position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;color:#ffffff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;font-weight:700;letter-spacing:0.06em;background:transparent;z-index:10;line-height:1;-webkit-text-stroke:2px #bbbbbb;text-stroke:2px #bbbbbb;margin-top:-80px;">01:00</div>
  <div class="timer-controls">
    <button class="pause-play-btn" id="pausePlayBtn">‚ñ∂</button>
    <button class="mode-switch-btn" id="modeSwitchBtn" title="Switch between Focus and Break">üîÑ</button>
    <button class="foreground-toggle-btn" id="foregroundToggleBtn" title="Toggle Foreground Display">üì±</button>
  </div>
  <!-- Foreground Widget -->
  <div class="foreground-widget" id="foregroundWidget">
    <div class="foreground-widget-header">
      <span class="foreground-widget-title" id="foregroundWidgetTitle">Timer</span>
      <button class="foreground-widget-close" id="foregroundWidgetClose">√ó</button>
    </div>
    <div class="foreground-widget-time" id="foregroundWidgetTime">01:00</div>
    <div class="foreground-widget-controls">
      <button class="foreground-widget-btn" id="foregroundPausePlayBtn">Start</button>
      <button class="foreground-widget-btn secondary" id="foregroundModeSwitchBtn" style="display: none;">üîÑ</button>
    </div>
  </div>
  <audio id="timerSound" preload="auto">
    <source src="birds-singing-in-tree.wav" type="audio/wav">
  </audio>
  <audio id="backgroundMusic" preload="auto">
    <source src="hiphop_playlist/dusty_loops1.mp3" type="audio/mpeg">
  </audio>
  <!-- Fullscreen SVG with gradient content distorted by turbulence -->
  <svg id="liquidGlassBg" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
    <defs>
      <!-- Animated gradient; colors will be shifted via JS (HSL drift) -->
      <linearGradient id="lg" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop id="s0" offset="0%" stop-color="#3a6ff0" />
        <stop id="s1" offset="50%" stop-color="#7ce3ff" />
        <stop id="s2" offset="100%" stop-color="#7bffb1" />
      </linearGradient>

      <!-- Liquid glass filter: noise + displacement + slight blur -->
      <filter id="liquid" x="-20%" y="-20%" width="140%" height="140%">
        <feTurbulence id="turb" type="turbulence" baseFrequency="0.005 0.009" numOctaves="2" seed="2" result="noise" />
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="55" xChannelSelector="R" yChannelSelector="G" />
        <feGaussianBlur stdDeviation="0.8" />
      </filter>
    </defs>

    <!-- Content to distort: a rect filled with our gradient -->
    <g filter="url(#liquid)">
      <rect x="-50" y="-50" width="1100" height="1100" fill="url(#lg)" />
    </g>
  </svg>
  <canvas id="grainCanvas" class="grain"></canvas>

<script>
(function(){
  // Menu toggle
  const menuButton = document.getElementById('menuButton');
  const menuItems = document.getElementById('menuItems');
  menuButton.addEventListener('click', function(e) {
    e.stopPropagation();
    menuItems.classList.toggle('open');
  });
  document.addEventListener('click', function(e) {
    if (!menuButton.contains(e.target) && !menuItems.contains(e.target)) {
      menuItems.classList.remove('open');
    }
  });

  // Timer settings
  const timerInput = document.getElementById('timerInput');
  const applyTimerBtn = document.getElementById('applyTimerBtn');
  const backgroundType = document.getElementById('backgroundType');
  const backgroundColorPicker = document.getElementById('backgroundColorPicker');
  const colorPickerContainer = document.getElementById('colorPickerContainer');
  const liquidGlassBg = document.getElementById('liquidGlassBg');
  const grainCanvas = document.getElementById('grainCanvas');
  
  // Background state
  let backgroundMode = 'liquid-glass'; // 'liquid-glass' or 'solid-color'
  let backgroundColor = '#0b0f14'; // Default dark background
  
  // Show/hide color picker based on background type
  backgroundType.addEventListener('change', function() {
    if (this.value === 'solid-color') {
      colorPickerContainer.style.display = 'block';
    } else {
      colorPickerContainer.style.display = 'none';
    }
  });
  // Keep timer color picker visible while hovering submenu; hide with slight delay on leave
  let timerPickerHideTimeout = null;
  const timerSubmenu = applyTimerBtn.closest('.submenu');
  function showTimerPickerIfNeeded() {
    if (backgroundType.value === 'solid-color') {
      colorPickerContainer.style.display = 'block';
    }
  }
  function hideTimerPicker() {
    colorPickerContainer.style.display = 'none';
  }
  if (timerSubmenu) {
    timerSubmenu.addEventListener('mouseenter', function() {
      if (timerPickerHideTimeout) { clearTimeout(timerPickerHideTimeout); timerPickerHideTimeout = null; }
      showTimerPickerIfNeeded();
    });
    timerSubmenu.addEventListener('mouseleave', function() {
      timerPickerHideTimeout = setTimeout(hideTimerPicker, 200);
    });
  }
  
  // Pomodoro settings
  const focusInput = document.getElementById('focusInput');
  const breakInput = document.getElementById('breakInput');
  const applyPomodoroBtn = document.getElementById('applyPomodoroBtn');
  const pomodoroBackgroundType = document.getElementById('pomodoroBackgroundType');
  const focusColorPicker = document.getElementById('focusColorPicker');
  const breakColorPicker = document.getElementById('breakColorPicker');
  const pomodoroColorPickerContainer = document.getElementById('pomodoroColorPickerContainer');
  const setFocusColorBtn = document.getElementById('setFocusColorBtn');
  const setBreakColorBtn = document.getElementById('setBreakColorBtn');
  
  // Pomodoro background state
  let pomodoroBackgroundMode = 'liquid-glass'; // 'liquid-glass' or 'solid-color'
  let pomodoroFocusColor = '#0b0f14'; // Default dark background for focus
  let pomodoroBreakColor = '#1a2f3a'; // Default darker background for break
  
  // Show/hide color pickers based on Pomodoro background type
  pomodoroBackgroundType.addEventListener('change', function() {
    if (this.value === 'solid-color') {
      pomodoroColorPickerContainer.style.display = 'block';
    } else {
      pomodoroColorPickerContainer.style.display = 'none';
    }
  });
  // Keep pomodoro color pickers visible while hovering submenu; hide with slight delay on leave
  let pomodoroPickerHideTimeout = null;
  const pomodoroSubmenu = applyPomodoroBtn.closest('.submenu');
  function showPomodoroPickersIfNeeded() {
    if (pomodoroBackgroundType.value === 'solid-color') {
      pomodoroColorPickerContainer.style.display = 'block';
    }
  }
  function hidePomodoroPickers() {
    pomodoroColorPickerContainer.style.display = 'none';
  }
  if (pomodoroSubmenu) {
    pomodoroSubmenu.addEventListener('mouseenter', function() {
      if (pomodoroPickerHideTimeout) { clearTimeout(pomodoroPickerHideTimeout); pomodoroPickerHideTimeout = null; }
      showPomodoroPickersIfNeeded();
    });
    pomodoroSubmenu.addEventListener('mouseleave', function() {
      pomodoroPickerHideTimeout = setTimeout(hidePomodoroPickers, 200);
    });
  }

  // Set buttons for Pomodoro colors
  setFocusColorBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    pomodoroFocusColor = focusColorPicker.value;
    if (pomodoroBackgroundMode === 'solid-color' && isFocusMode) {
      document.body.style.background = pomodoroFocusColor;
    }
  });
  setBreakColorBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    pomodoroBreakColor = breakColorPicker.value;
    if (pomodoroBackgroundMode === 'solid-color' && !isFocusMode) {
      document.body.style.background = pomodoroBreakColor;
    }
  });
  
  const TIMER_MINUTES = 30; // CHANGE THIS to set timer minutes
  const TIMER_SECONDS = 10; // CHANGE THIS to set timer seconds
  let focusDurationMs = 25 * 60 * 1000; // Default 25 minutes
  let breakDurationMs = 5 * 60 * 1000; // Default 5 minutes
  let timerDurationMs = focusDurationMs;
  let isFocusMode = true; // true = focus, false = break
  let isPomodoroMode = true; // true = Pomodoro (focus-break cycle), false = simple timer
  const TIMER_FONT_SIZE = 300; // px - CHANGE THIS VALUE to modify timer font size
  const timerEl = document.getElementById('timer');
  timerEl.style.fontSize = TIMER_FONT_SIZE + 'px';
  let startTime = performance.now();
  let last = startTime;
  let rafId1 = 0, rafId2 = 0;
  let isPaused = true; // Start paused when page loads
  let pausedElapsed = 0; // Accumulated elapsed time when paused
  let pauseStartTime = 0;
  const baseTitle = document.title;
  const timerSound = document.getElementById('timerSound');
  let hasPlayedSound = false; // Track if sound has been played for current timer completion
  
  // Background music playlist
  const backgroundMusic = document.getElementById('backgroundMusic');
  const musicPlaylist = [
    'hiphop_playlist/dusty_loops1.mp3',
    'hiphop_playlist/dusty_loops2.mp3'
  ];
  let currentMusicIndex = 0;
  let isMusicMuted = false;
  let musicPlayMode = 'auto'; // 'auto' or 'manual'
  
  // Function to load and play next song in playlist
  function playNextMusic() {
    backgroundMusic.src = musicPlaylist[currentMusicIndex];
    backgroundMusic.load();
    if (!isPaused && !isMusicMuted && musicPlayMode === 'auto') {
      backgroundMusic.play().catch(err => console.log('Could not play background music:', err));
    }
  }
  
  // When a song ends, play the next one (only in auto mode)
  backgroundMusic.addEventListener('ended', function() {
    if (musicPlayMode === 'auto') {
      currentMusicIndex = (currentMusicIndex + 1) % musicPlaylist.length;
      updateMusicSelect();
      playNextMusic();
    }
  });
  
  // Function to control music based on timer state
  function updateMusicState() {
    // Only auto-control music if in auto mode
    if (musicPlayMode === 'manual') {
      return;
    }
    
    if (!isPaused && !isMusicMuted) {
      // Timer is running and not muted - play music
      // Ensure music source is set to current playlist item
      const currentSrc = musicPlaylist[currentMusicIndex];
      if (!backgroundMusic.src || !backgroundMusic.src.includes(currentSrc)) {
        backgroundMusic.src = currentSrc;
        backgroundMusic.load();
      }
      if (backgroundMusic.paused) {
        backgroundMusic.play().catch(err => console.log('Could not play background music:', err));
      }
    } else {
      // Timer is paused or muted - pause music
      if (!backgroundMusic.paused) {
        backgroundMusic.pause();
      }
    }
  }
  
  // Music controls
  const musicMuteToggle = document.getElementById('musicMuteToggle');
  const musicPlayModeSelect = document.getElementById('musicPlayMode');
  const musicSelect = document.getElementById('musicSelect');
  const playSelectedMusicBtn = document.getElementById('playSelectedMusic');
  
  // Update mute button text
  function updateMuteButton() {
    musicMuteToggle.textContent = isMusicMuted ? 'Unmute' : 'Mute';
  }
  
  // Mute toggle
  musicMuteToggle.addEventListener('click', function() {
    isMusicMuted = !isMusicMuted;
    updateMuteButton();
    if (isMusicMuted) {
      backgroundMusic.pause();
    } else {
      // If unmuted and timer is running, resume music (if in auto mode)
      if (!isPaused && musicPlayMode === 'auto') {
        updateMusicState();
      }
    }
  });
  
  // Play mode change
  musicPlayModeSelect.addEventListener('change', function() {
    musicPlayMode = this.value;
    if (musicPlayMode === 'manual') {
      // Stop auto-playing when switching to manual
      if (!isPaused) {
        backgroundMusic.pause();
      }
    } else {
      // Resume auto-play if timer is running
      if (!isPaused && !isMusicMuted) {
        updateMusicState();
      }
    }
  });
  
  // Manual song selection and play
  playSelectedMusicBtn.addEventListener('click', function() {
    const selectedIndex = parseInt(musicSelect.value);
    currentMusicIndex = selectedIndex;
    backgroundMusic.src = musicPlaylist[currentMusicIndex];
    backgroundMusic.load();
    if (!isMusicMuted) {
      backgroundMusic.play().catch(err => console.log('Could not play background music:', err));
    }
    updateMusicSelect();
  });
  
  // Update music select when dropdown changes (for manual selection tracking)
  musicSelect.addEventListener('change', function() {
    // Just update the index, don't play automatically
    currentMusicIndex = parseInt(this.value);
  });
  
  // Update music select dropdown to reflect current song
  function updateMusicSelect() {
    musicSelect.value = currentMusicIndex.toString();
  }
  
  // Initialize mute button
  updateMuteButton();
  
  // Background-safe time/title helpers
  function computeRemainingMs(now){
    const current = now != null ? now : performance.now();
    const elapsed = isPaused ? pausedElapsed : (current - startTime + pausedElapsed);
    return Math.max(0, timerDurationMs - elapsed);
  }
  function updateTitleFromRemaining(remainingMs){
    const remaining = remainingMs != null ? remainingMs : computeRemainingMs();
    const totalSeconds = Math.floor(remaining / 1000);
    const clamped = Math.max(0, totalSeconds);
    const mm = Math.floor(clamped / 60);
    const ss = clamped % 60;
    const modeLabel = isPomodoroMode ? (isFocusMode ? 'Focus' : 'Break') : 'Timer';
    const statusIcon = isPaused ? '‚è∏' : '‚ñ∂';
    document.title = `${statusIcon} ${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')} ‚Ä¢ ${modeLabel}`;
  }
  
  // Pause/Play button
  const pausePlayBtn = document.getElementById('pausePlayBtn');
  pausePlayBtn.addEventListener('click', function() {
    isPaused = !isPaused;
    if (isPaused) {
      // Pause: accumulate elapsed time and stop animation
      const now = performance.now();
      pausedElapsed += now - startTime;
      pauseStartTime = now;
      pausePlayBtn.textContent = '‚ñ∂';
      // Pause music
      updateMusicState();
      // Update foreground widget if active
      if (isForegroundMode) {
        updateForegroundWidget();
      }
      // Don't stop the frame function, but it will skip timer updates
    } else {
      // Resume: reset startTime to current time
      const now = performance.now();
      startTime = now;
      last = now;
      // If pausedElapsed is 0, we're starting fresh (after auto-pause) - keep it at 0
      // If pausedElapsed > 0, we're resuming a manual pause - keep the accumulated time
      pausePlayBtn.textContent = '‚è∏';
      // Resume music
      updateMusicState();
      // Update foreground widget if active
      if (isForegroundMode) {
        updateForegroundWidget();
      }
    }
  });
  
  // Mode Switch button (Focus/Break toggle)
  const modeSwitchBtn = document.getElementById('modeSwitchBtn');
  function updateModeSwitchVisibility() {
    if (isPomodoroMode) {
      modeSwitchBtn.classList.add('visible');
    } else {
      modeSwitchBtn.classList.remove('visible');
    }
  }
  function switchMode() {
    if (!isPomodoroMode) return; // Only switch in Pomodoro mode
    
    // Toggle between focus and break
    isFocusMode = !isFocusMode;
    timerDurationMs = isFocusMode ? focusDurationMs : breakDurationMs;
    
    // Reset timer
    startTime = performance.now();
    last = startTime;
    pausedElapsed = 0;
    isPaused = true; // Pause after switching
    pausePlayBtn.textContent = '‚ñ∂';
    hasPlayedSound = false; // Reset sound flag for new timer
    
    // Update background color if in Pomodoro solid color mode
    if (pomodoroBackgroundMode === 'solid-color') {
      document.body.style.background = isFocusMode ? pomodoroFocusColor : pomodoroBreakColor;
    }
    
    // Pause music when switching modes (since timer is paused)
    updateMusicState();
    
    // Update foreground widget if active
    if (isForegroundMode) {
      updateForegroundWidget();
    }
    
    console.log('Mode switched to:', isFocusMode ? 'Focus' : 'Break');
  }
  modeSwitchBtn.addEventListener('click', switchMode);
  
  // Initialize mode switch button visibility
  updateModeSwitchVisibility();
  
  // Foreground widget functionality (Picture-in-Picture API)
  let foregroundPopup = null;
  let isForegroundMode = false;
  let pipCanvas = null;
  let pipCtx = null;
  let pipVideo = null;
  let pipStream = null;
  let pipWindow = null;
  const foregroundToggleBtn = document.getElementById('foregroundToggleBtn');
  const foregroundWidget = document.getElementById('foregroundWidget');
  const foregroundWidgetTime = document.getElementById('foregroundWidgetTime');
  const foregroundWidgetTitle = document.getElementById('foregroundWidgetTitle');
  const foregroundPausePlayBtn = document.getElementById('foregroundPausePlayBtn');
  const foregroundModeSwitchBtn = document.getElementById('foregroundModeSwitchBtn');
  const foregroundWidgetClose = document.getElementById('foregroundWidgetClose');
  
  // Create canvas and video for Picture-in-Picture
  function createPipElements() {
    if (!pipCanvas) {
      pipCanvas = document.createElement('canvas');
      pipCanvas.width = 320;
      pipCanvas.height = 240;
      pipCanvas.style.display = 'none';
      document.body.appendChild(pipCanvas);
      pipCtx = pipCanvas.getContext('2d');
    }
    
    if (!pipVideo) {
      pipVideo = document.createElement('video');
      pipVideo.muted = true;
      pipVideo.playsInline = true;
      pipVideo.controls = false;
      pipVideo.disablePictureInPicture = false;
      pipVideo.style.display = 'none';
      document.body.appendChild(pipVideo);
    }
    
    return { canvas: pipCanvas, video: pipVideo };
  }
  
  // Draw timer on canvas
  function drawTimerOnCanvas() {
    if (!pipCanvas || !pipCtx) return;
    
    const remaining = computeRemainingMs();
    const totalSeconds = Math.floor(remaining / 1000);
    const clamped = Math.max(0, totalSeconds);
    const mm = Math.floor(clamped / 60);
    const ss = clamped % 60;
    const timeText = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    
    const modeLabel = isPomodoroMode ? (isFocusMode ? 'Focus' : 'Break') : 'Timer';
    const buttonText = isPaused ? 'Start' : 'Pause';
    
    // Clear canvas
    pipCtx.fillStyle = 'rgba(20, 20, 25, 0.95)';
    pipCtx.fillRect(0, 0, pipCanvas.width, pipCanvas.height);
    
    // Draw timer text
    pipCtx.fillStyle = '#ffffff';
    pipCtx.font = 'bold 48px system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
    pipCtx.textAlign = 'center';
    pipCtx.textBaseline = 'middle';
    pipCtx.fillText(timeText, pipCanvas.width / 2, pipCanvas.height / 2 - 30);
    
    // Draw mode label (smaller)
    pipCtx.font = '14px system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
    pipCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    pipCtx.fillText(modeLabel, pipCanvas.width / 2, pipCanvas.height / 2 + 20);
  }
  
  // Stream canvas to video element
  function streamCanvasToVideo() {
    if (!pipCanvas || !pipVideo) return;
    
    // Stop existing stream if any
    if (pipStream) {
      pipStream.getTracks().forEach(track => track.stop());
    }
    
    // Create stream from canvas
    pipStream = pipCanvas.captureStream(30); // 30 FPS
    pipVideo.srcObject = pipStream;
    pipVideo.play().catch(err => console.log('Video play error:', err));
  }
  
  // Function to update foreground widget display (for inline widget, popup, and PiP)
  function updateForegroundWidget() {
    const remaining = computeRemainingMs();
    const totalSeconds = Math.floor(remaining / 1000);
    const clamped = Math.max(0, totalSeconds);
    const mm = Math.floor(clamped / 60);
    const ss = clamped % 60;
    
    // Update inline widget if visible
    if (isForegroundMode && foregroundWidget && foregroundWidget.classList.contains('active')) {
      foregroundWidgetTime.textContent = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
      const modeLabel = isPomodoroMode ? (isFocusMode ? 'Focus' : 'Break') : 'Timer';
      foregroundWidgetTitle.textContent = modeLabel;
      foregroundPausePlayBtn.textContent = isPaused ? 'Start' : 'Pause';
      if (isPomodoroMode) {
        foregroundModeSwitchBtn.style.display = 'block';
      } else {
        foregroundModeSwitchBtn.style.display = 'none';
      }
    }
    
    // Update popup window if open (always update, even if inline widget is hidden)
    if (foregroundPopup && !foregroundPopup.closed) {
      const remainingSeconds = Math.floor(remaining / 1000);
      foregroundPopup.postMessage({
        type: 'timerUpdate',
        remaining: remainingSeconds,
        isPaused: isPaused,
        isPomodoroMode: isPomodoroMode,
        isFocusMode: isFocusMode
      }, '*');
    }
    
    // Update Picture-in-Picture canvas if active
    if (pipWindow && !document.pictureInPictureElement) {
      // PiP was closed
      pipWindow = null;
      isForegroundMode = false;
      if (pipCanvas) pipCanvas.style.display = 'none';
      if (pipVideo) pipVideo.style.display = 'none';
      if (pipStream) {
        pipStream.getTracks().forEach(track => track.stop());
        pipStream = null;
      }
    } else if (document.pictureInPictureElement === pipVideo) {
      // PiP is active, update canvas (which streams to video)
      drawTimerOnCanvas();
    }
    
    // Store state in localStorage as fallback (always store for popup to read)
    try {
      localStorage.setItem('timerState', JSON.stringify({
        remaining: remaining,
        isPaused: isPaused,
        isPomodoroMode: isPomodoroMode,
        isFocusMode: isFocusMode
      }));
    } catch (e) {
      console.error('Error storing timer state:', e);
    }
  }
  
  // Listen for messages from popup window
  window.addEventListener('message', function(event) {
    if (event.data.type === 'requestState') {
      // Send current state to popup
      const remaining = computeRemainingMs();
      const remainingSeconds = Math.floor(remaining / 1000);
      event.source.postMessage({
        type: 'timerUpdate',
        remaining: remainingSeconds,
        isPaused: isPaused,
        isPomodoroMode: isPomodoroMode,
        isFocusMode: isFocusMode
      }, '*');
    } else if (event.data.type === 'pausePlay') {
      // Trigger pause/play from popup
      pausePlayBtn.click();
    } else if (event.data.type === 'switchMode') {
      // Trigger mode switch from popup
      switchMode();
    }
  });
  
  // Toggle foreground mode (uses Picture-in-Picture API)
  foregroundToggleBtn.addEventListener('click', async function() {
    // Check if Picture-in-Picture is supported
    if (!document.pictureInPictureEnabled) {
      // Fallback to popup window
      if (foregroundPopup && !foregroundPopup.closed) {
        foregroundPopup.close();
        foregroundPopup = null;
        isForegroundMode = false;
        document.body.classList.remove('foreground-mode');
        foregroundWidget.classList.remove('active');
      } else {
        // Open fallback popup window
        const width = 320;
        const height = 240;
        const left = screen.width - width - 20;
        const top = screen.height - height - 20;
        
        const features = [
          `width=${width}`,
          `height=${height}`,
          `left=${left}`,
          `top=${top}`,
          'popup=1',
          'resizable=1',
          'scrollbars=0',
          'toolbar=0',
          'location=0',
          'status=0',
          'menubar=0'
        ].join(',');
        
        foregroundPopup = window.open('foreground-widget.html', 'TimerWidget', features);
        
        if (foregroundPopup) {
          isForegroundMode = true;
          document.body.classList.add('foreground-mode');
          foregroundWidget.classList.add('active');
          setTimeout(() => updateForegroundWidget(), 200);
          
          const checkClosed = setInterval(() => {
            if (foregroundPopup && foregroundPopup.closed) {
              isForegroundMode = false;
              document.body.classList.remove('foreground-mode');
              foregroundWidget.classList.remove('active');
              foregroundPopup = null;
              clearInterval(checkClosed);
            }
          }, 500);
        } else {
          alert('Popup blocked. Please allow popups for this site.');
        }
      }
      return;
    }
    
    // Use Picture-in-Picture API
    try {
      if (document.pictureInPictureElement) {
        // Exit Picture-in-Picture
        await document.exitPictureInPicture();
        pipWindow = null;
        isForegroundMode = false;
        if (pipCanvas) pipCanvas.style.display = 'none';
        if (pipVideo) pipVideo.style.display = 'none';
        if (pipStream) {
          pipStream.getTracks().forEach(track => track.stop());
          pipStream = null;
        }
        document.body.classList.remove('foreground-mode');
        foregroundWidget.classList.remove('active');
      } else {
        // Enter Picture-in-Picture
        const { canvas, video } = createPipElements();
        drawTimerOnCanvas();
        streamCanvasToVideo();
        
        // Wait for video to be ready
        await new Promise((resolve) => {
          if (pipVideo.readyState >= 2) {
            resolve();
          } else {
            pipVideo.addEventListener('loadeddata', resolve, { once: true });
          }
        });
        
        try {
          await pipVideo.requestPictureInPicture();
          pipWindow = video;
          isForegroundMode = true;
          document.body.classList.add('foreground-mode');
          foregroundWidget.classList.add('active');
          
          // Update canvas continuously while in PiP
          const pipUpdateInterval = setInterval(() => {
            if (document.pictureInPictureElement === video) {
              drawTimerOnCanvas();
            } else {
              clearInterval(pipUpdateInterval);
              pipWindow = null;
              isForegroundMode = false;
              canvas.style.display = 'none';
              video.style.display = 'none';
              if (pipStream) {
                pipStream.getTracks().forEach(track => track.stop());
                pipStream = null;
              }
            }
          }, 100);
        } catch (err) {
          console.error('Error entering Picture-in-Picture:', err);
          alert('Could not enter Picture-in-Picture mode. ' + err.message);
          if (pipStream) {
            pipStream.getTracks().forEach(track => track.stop());
            pipStream = null;
          }
        }
      }
    } catch (err) {
      console.error('Picture-in-Picture error:', err);
    }
  });
  
  // Listen for PiP close events
  document.addEventListener('leavepictureinpicture', function() {
    pipWindow = null;
    isForegroundMode = false;
    if (pipCanvas) pipCanvas.style.display = 'none';
    if (pipVideo) pipVideo.style.display = 'none';
    if (pipStream) {
      pipStream.getTracks().forEach(track => track.stop());
      pipStream = null;
    }
    document.body.classList.remove('foreground-mode');
    foregroundWidget.classList.remove('active');
  });
  
  // Close foreground widget (inline)
  foregroundWidgetClose.addEventListener('click', function() {
    isForegroundMode = false;
    document.body.classList.remove('foreground-mode');
    foregroundWidget.classList.remove('active');
    if (foregroundPopup && !foregroundPopup.closed) {
      foregroundPopup.close();
      foregroundPopup = null;
    }
  });
  
  // Foreground widget pause/play button (inline)
  foregroundPausePlayBtn.addEventListener('click', function() {
    pausePlayBtn.click();
    updateForegroundWidget();
  });
  
  // Foreground widget mode switch button (inline)
  foregroundModeSwitchBtn.addEventListener('click', function() {
    switchMode();
    updateForegroundWidget();
  });
  
  // Function to apply background settings
  function applyBackgroundSettings() {
    backgroundMode = backgroundType.value;
    
    if (backgroundMode === 'solid-color') {
      backgroundColor = backgroundColorPicker.value;
      // Hide liquid glass elements
      liquidGlassBg.style.display = 'none';
      grainCanvas.style.display = 'none';
      // Set solid background color
      document.body.style.background = backgroundColor;
      // Stop grain animation
      if (rafId2) {
        cancelAnimationFrame(rafId2);
        rafId2 = 0;
      }
    } else {
      // Show liquid glass elements
      liquidGlassBg.style.display = 'block';
      grainCanvas.style.display = 'block';
      // Reset body background to default
      document.body.style.background = '#0b0f14';
      // Start grain animation if not already running
      if (!rafId2) {
        rafId2 = requestAnimationFrame(drawGrain);
      }
    }
  }
  
  applyTimerBtn.addEventListener('click', function() {
    const timerMinutes = parseInt(timerInput.value) || 25;
    timerDurationMs = timerMinutes * 60 * 1000;
    isPomodoroMode = false; // Disable Pomodoro cycling - use simple timer
    isFocusMode = true; // Set to focus mode (though it won't cycle)
    startTime = performance.now();
    last = startTime;
    pausedElapsed = 0; // Reset paused time
    isPaused = false; // Reset pause state
    pausePlayBtn.textContent = '‚è∏'; // Reset button icon
    hasPlayedSound = false; // Reset sound flag for new timer
    
    // Update mode switch button visibility
    updateModeSwitchVisibility();
    
    // Apply background settings (only for simple timer mode)
    applyBackgroundSettings();
    
    // Start music when timer starts
    updateMusicState();
    
    // Update foreground widget if active
    if (isForegroundMode) {
      updateForegroundWidget();
    }
    
    console.log('Timer settings applied:', { 
      minutes: timerMinutes, 
      mode: 'simple timer (focus only)',
      background: backgroundMode,
      backgroundColor: backgroundMode === 'solid-color' ? backgroundColor : 'N/A'
    });
    // Restart animation if it had stopped
    if (!rafId1) {
      rafId1 = requestAnimationFrame(frame);
    }
    // Only start grain animation if liquid glass mode
    // Timer settings use backgroundMode, Pomodoro uses pomodoroBackgroundMode
    const shouldShowLiquidGlass = isPomodoroMode 
      ? (pomodoroBackgroundMode === 'liquid-glass')
      : (backgroundMode === 'liquid-glass');
    
    if (shouldShowLiquidGlass) {
      if (!rafId2) {
        rafId2 = requestAnimationFrame(drawGrain);
      }
    } else {
      // Stop grain animation if solid color mode
      if (rafId2) {
        cancelAnimationFrame(rafId2);
        rafId2 = 0;
      }
    }
    // Close the menu after applying
    menuItems.classList.remove('open');
  });
  
  // Function to apply Pomodoro background settings
  function applyPomodoroBackgroundSettings() {
    pomodoroBackgroundMode = pomodoroBackgroundType.value;
    pomodoroFocusColor = focusColorPicker.value;
    pomodoroBreakColor = breakColorPicker.value;
    
    // Apply background based on current mode (focus or break)
    if (pomodoroBackgroundMode === 'solid-color') {
      // Hide liquid glass elements
      liquidGlassBg.style.display = 'none';
      grainCanvas.style.display = 'none';
      // Set color based on current mode
      document.body.style.background = isFocusMode ? pomodoroFocusColor : pomodoroBreakColor;
      // Stop grain animation
      if (rafId2) {
        cancelAnimationFrame(rafId2);
        rafId2 = 0;
      }
    } else {
      // Show liquid glass elements
      liquidGlassBg.style.display = 'block';
      grainCanvas.style.display = 'block';
      // Reset body background to default
      document.body.style.background = '#0b0f14';
      // Start grain animation if not already running
      if (!rafId2) {
        rafId2 = requestAnimationFrame(drawGrain);
      }
    }
  }
  
  applyPomodoroBtn.addEventListener('click', function() {
    const focusMinutes = parseInt(focusInput.value) || 25;
    const breakMinutes = parseInt(breakInput.value) || 5;
    focusDurationMs = focusMinutes * 60 * 1000;
    breakDurationMs = breakMinutes * 60 * 1000;
    // Enable Pomodoro mode (focus-break cycling)
    isPomodoroMode = true;
    // Start with focus mode
    isFocusMode = true;
    timerDurationMs = focusDurationMs;
    startTime = performance.now();
    last = startTime;
    pausedElapsed = 0; // Reset paused time
    isPaused = false; // Reset pause state
    pausePlayBtn.textContent = '‚è∏'; // Reset button icon
    hasPlayedSound = false; // Reset sound flag for new timer
    
    // Update mode switch button visibility
    updateModeSwitchVisibility();
    
    // Apply Pomodoro background settings
    applyPomodoroBackgroundSettings();
    
    // Start music when timer starts
    updateMusicState();
    
    // Update foreground widget if active
    if (isForegroundMode) {
      updateForegroundWidget();
    }
    
    console.log('Pomodoro settings applied:', { 
      focus: focusMinutes, 
      break: breakMinutes, 
      mode: 'Pomodoro (focus-break cycle)',
      background: pomodoroBackgroundMode,
      focusColor: pomodoroBackgroundMode === 'solid-color' ? pomodoroFocusColor : 'N/A',
      breakColor: pomodoroBackgroundMode === 'solid-color' ? pomodoroBreakColor : 'N/A'
    });
    // Restart animation if it had stopped
    if (!rafId1) {
      rafId1 = requestAnimationFrame(frame);
    }
    // Close the menu after applying
    menuItems.classList.remove('open');
  });
  // Gentle hue drift for gradient stops with randomized starting colors
  function rand(min, max) { return Math.random() * (max - min) + min; }
  const stops = [
    { el: document.getElementById('s0'), hue: rand(0, 360), sat: 75, lit: 55, speed: 0.004 },
    { el: document.getElementById('s1'), hue: rand(0, 360), sat: 80, lit: 62, speed: -0.006 },
    { el: document.getElementById('s2'), hue: rand(0, 360), sat: 75, lit: 58, speed: 0.005 }
  ];

  // Animate turbulence parameters for organic flow
  const turb = document.getElementById('turb');
  let t = 0;

  function frame(now){
    const dt = now - last; last = now; t += dt;
    
    // Calculate elapsed time (use accumulated paused time)
    let elapsed = isPaused ? pausedElapsed : (now - startTime + pausedElapsed);
    
    // If we just started (pausedElapsed is 0 and not paused), ensure we start from exactly 0
    if (!isPaused && pausedElapsed === 0 && (now - startTime) < 100) {
      // Very early in the timer (first 100ms), ensure clean start
      elapsed = now - startTime;
    }
    
    let remaining = Math.max(0, timerDurationMs - elapsed);
    
    // Timer logic (only when not paused)
    if (!isPaused) {
      // If timer finished, automatically pause
      if (remaining <= 0) {
        // Play sound if not already played for this completion
        if (!hasPlayedSound) {
          timerSound.currentTime = 0; // Reset to beginning
          timerSound.play().catch(err => console.log('Could not play sound:', err));
          hasPlayedSound = true;
        }
        
        // Automatically pause
        isPaused = true;
        pausedElapsed = 0; // Reset for new timer
        pausePlayBtn.textContent = '‚ñ∂';
        // Pause music when timer auto-pauses
        updateMusicState();
        
        // Update foreground widget if active
        if (isForegroundMode) {
          updateForegroundWidget();
        }
        
        // Only switch to the other mode if in Pomodoro mode
        if (isPomodoroMode) {
          // Switch to the other mode (focus <-> break)
          isFocusMode = !isFocusMode;
          timerDurationMs = isFocusMode ? focusDurationMs : breakDurationMs;
          startTime = performance.now();
          last = startTime;
          remaining = timerDurationMs; // Show full time for next timer, but paused
          hasPlayedSound = false; // Reset sound flag for new timer
          
          // Update background color if in Pomodoro solid color mode
          if (pomodoroBackgroundMode === 'solid-color') {
            document.body.style.background = isFocusMode ? pomodoroFocusColor : pomodoroBreakColor;
          }
          
          console.log('Timer finished. Auto-paused. Next mode:', isFocusMode ? 'Focus' : 'Break');
        } else {
          // Simple timer mode - just pause, don't switch modes
          console.log('Timer finished. Auto-paused. (Simple timer mode - no cycle)');
        }
      }
    }
    
    // Always update timer display - use floor instead of ceil to prevent flicker
    const totalSeconds = Math.floor(remaining / 1000);
    const clamped = Math.max(0, totalSeconds);
    const mm = Math.floor(clamped / 60);
    const ss = clamped % 60;
    timerEl.textContent = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    // Update foreground widget/popup (always update popup if open)
    updateForegroundWidget();
    // Update document title with timer and mode (rAF path)
    updateTitleFromRemaining(remaining);

    // Update gradient colors and turbulence only if liquid glass mode
    // Check both timer background mode and Pomodoro background mode
    const shouldShowLiquidGlass = isPomodoroMode 
      ? (pomodoroBackgroundMode === 'liquid-glass')
      : (backgroundMode === 'liquid-glass');
    
    if (shouldShowLiquidGlass) {
      // Update gradient colors (always animate when liquid glass is active)
      for (const s of stops){
        s.hue = (s.hue + s.speed * dt) % 360;
        s.el.setAttribute('stop-color', hslToHex(s.hue, s.sat, s.lit));
      }

      // Morph turbulence for a flowing refraction (always animate when liquid glass is active)
      const bfX = 0.0045 + 0.0015 * Math.sin(t * 0.0004);
      const bfY = 0.0085 + 0.0020 * Math.cos(t * 0.0003);
      const seed = 2 + Math.sin(t * 0.0002) * 0.5;
      turb.setAttribute('baseFrequency', bfX.toFixed(5) + ' ' + bfY.toFixed(5));
      turb.setAttribute('seed', seed.toFixed(3));
    }

    // Always continue the animation
    rafId1 = requestAnimationFrame(frame);
  }
  rafId1 = requestAnimationFrame(frame);

  // Keep document title updating while tab is inactive (rAF is throttled/paused)
  // Also check for timer completion and play sound even when tab is inactive
  setInterval(function(){
    if (document.hidden) {
      updateTitleFromRemaining();
      // Update foreground widget/popup even when tab is hidden
      updateForegroundWidget();
    }
    
    // Check if timer has finished (even when tab is inactive)
    if (!isPaused) {
      const now = performance.now();
      const elapsed = now - startTime + pausedElapsed;
      const remaining = Math.max(0, timerDurationMs - elapsed);
      
      if (remaining <= 0 && !hasPlayedSound) {
        // Timer finished - play sound even if tab is inactive
        timerSound.currentTime = 0;
        timerSound.play().catch(err => console.log('Could not play sound:', err));
        hasPlayedSound = true;
        
        // Auto-pause and handle mode switching
        isPaused = true;
        pausedElapsed = 0;
        pausePlayBtn.textContent = '‚ñ∂';
        // Pause music when timer auto-pauses
        updateMusicState();
        
        if (isPomodoroMode) {
          isFocusMode = !isFocusMode;
          timerDurationMs = isFocusMode ? focusDurationMs : breakDurationMs;
          startTime = performance.now();
          last = startTime;
          hasPlayedSound = false; // Reset for next timer
          
          if (pomodoroBackgroundMode === 'solid-color') {
            document.body.style.background = isFocusMode ? pomodoroFocusColor : pomodoroBreakColor;
          }
        }
      }
    }
  }, 1000);
  document.addEventListener('visibilitychange', function(){
    updateTitleFromRemaining();
    
    // When tab becomes visible, check if timer finished while hidden
    if (!document.hidden && !isPaused) {
      const now = performance.now();
      const elapsed = now - startTime + pausedElapsed;
      const remaining = Math.max(0, timerDurationMs - elapsed);
      
      if (remaining <= 0 && !hasPlayedSound) {
        // Timer finished while tab was hidden - play sound now
        timerSound.currentTime = 0;
        timerSound.play().catch(err => console.log('Could not play sound:', err));
        hasPlayedSound = true;
        
        // Auto-pause and handle mode switching
        isPaused = true;
        pausedElapsed = 0;
        pausePlayBtn.textContent = '‚ñ∂';
        // Pause music when timer auto-pauses
        updateMusicState();
        
        if (isPomodoroMode) {
          isFocusMode = !isFocusMode;
          timerDurationMs = isFocusMode ? focusDurationMs : breakDurationMs;
          startTime = performance.now();
          last = startTime;
          hasPlayedSound = false; // Reset for next timer
          
          if (pomodoroBackgroundMode === 'solid-color') {
            document.body.style.background = isFocusMode ? pomodoroFocusColor : pomodoroBreakColor;
          }
        }
      }
    }
  });

  // Subtle animated film grain for texture
  const grain = grainCanvas; // Use the ID reference
  const gctx = grain.getContext('2d', { alpha: true });
  function resize(){
    grain.width = innerWidth; grain.height = innerHeight;
  }
  addEventListener('resize', resize); resize();
  function drawGrain(){
    // Only animate grain if in liquid glass mode
    // Check both timer background mode and Pomodoro background mode
    const shouldShowLiquidGlass = isPomodoroMode 
      ? (pomodoroBackgroundMode === 'liquid-glass')
      : (backgroundMode === 'liquid-glass');
    
    if (!shouldShowLiquidGlass) {
      return;
    }
    const w = grain.width, h = grain.height;
    const img = gctx.createImageData(w, h);
    const data = img.data;
    for (let i = 0; i < data.length; i += 4){
      const v = 120 + ((Math.random() * 70) | 0); // 120..190
      data[i] = data[i+1] = data[i+2] = v; data[i+3] = 18; // low alpha
    }
    gctx.putImageData(img, 0, 0);
    // Continue the grain animation
    rafId2 = requestAnimationFrame(drawGrain);
  }
  rafId2 = requestAnimationFrame(drawGrain);

  // Utils
  function hslToHex(h, s, l){
    const a = s * Math.min(l, 100 - l) / 10000;
    const f = n => {
      const k = (n + h / 30) % 12;
      const c = l/100 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return Math.round(255 * c).toString(16).padStart(2, '0');
    };
    return '#' + f(0) + f(8) + f(4);
  }
  
  // Initialize gradient with random colors
  for (const s of stops) {
    s.el.setAttribute('stop-color', hslToHex(s.hue, s.sat, s.lit));
  }
  
  // Initialize music playlist - load first song
  backgroundMusic.src = musicPlaylist[currentMusicIndex];
  backgroundMusic.load();
  // Initialize music select dropdown
  updateMusicSelect();
})();
</script>
</body>
</html>

