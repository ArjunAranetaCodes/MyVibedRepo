<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gooey Lava Lamp</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #0b0f14; /* backdrop */
    overflow: hidden;
  }
  /* Optional subtle gradient background */
  body::before {
    content: "";
    position: fixed;
    inset: -20%;
    background: radial-gradient(60% 60% at 30% 30%, #0f223a 0%, #0b0f14 60%) no-repeat;
    filter: blur(40px);
    opacity: 0.8;
    z-index: -1;
  }
  svg {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
  }
  /* Initial tint (JS will override with animated HSL) */
  .blob { fill: #7fd1ff; }
  .blob.alt { fill: #66ffa6; }
</style>
</head>
<body>
  <!-- Full-screen SVG with a gooey filter -->
  <svg viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
    <defs>
      <!-- Gooey: blur then enhance alpha -->
      <filter id="goo">
        <feGaussianBlur in="SourceGraphic" stdDeviation="18" result="blur" />
        <feColorMatrix in="blur" mode="matrix"
          values="
            1 0 0 0 0
            0 1 0 0 0
            0 0 1 0 0
            0 0 0 35 -15" result="goo" />
        <feBlend in="SourceGraphic" in2="goo" />
      </filter>
    </defs>

    <!-- Apply goo filter to all blobs -->
    <g filter="url(#goo)" id="blobGroup">
      <!-- Circles will be populated/updated by JS -->
      <!-- You can pre-seed a few if you want fallback visuals -->
      <circle class="blob" cx="300" cy="300" r="80" />
      <circle class="blob alt" cx="700" cy="700" r="90" />
    </g>
  </svg>

<script>
  (function () {
    const svg = document.querySelector('svg');
    const group = document.getElementById('blobGroup');

    // Coordinate space matches viewBox (0..1000)
    const WIDTH = 1000;
    const HEIGHT = 1000;

    const NUM_BLOBS = 10;
    const MIN_R = 50;
    const MAX_R = 120;
    const MAX_SPEED = 0.12; // slower motion
    const PULSE_AMPL = 0.16; // slightly subtler
    const PULSE_SPEED = 0.0012; // slower pulsation
    const HUE_SPEED_MIN = 0.002; // deg/ms (very slow)
    const HUE_SPEED_MAX = 0.008; // deg/ms

    // Reuse or create circles
    function ensureCircles(n) {
      const existing = group.querySelectorAll('circle');
      for (let i = existing.length; i < n; i++) {
        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        c.setAttribute('class', i % 2 ? 'blob' : 'blob alt');
        group.appendChild(c);
      }
      return group.querySelectorAll('circle');
    }

    const circles = ensureCircles(NUM_BLOBS);

    // Blob model
    const blobs = Array.from({ length: NUM_BLOBS }, (_, i) => {
      const r = rand(MIN_R, MAX_R);
      return {
        cx: rand(r, WIDTH - r),
        cy: rand(r, HEIGHT - r),
        rBase: r,
        vx: rand(-MAX_SPEED, MAX_SPEED),
        vy: rand(-MAX_SPEED, MAX_SPEED),
        phase: Math.random() * Math.PI * 2,
        hue: Math.random() * 360,
        sat: rand(70, 95),
        lit: rand(55, 65),
        hueSpeed: (Math.random() < 0.5 ? 1 : -1) * rand(HUE_SPEED_MIN, HUE_SPEED_MAX),
        el: circles[i]
      };
    });

    // Assign random static colors to each blob
    for (const b of blobs) {
      const { r, g, b: bb } = hslToRgb(b.hue, b.sat, b.lit);
      b.el.style.fill = `rgb(${r}, ${g}, ${bb})`;
    }

    // Animation loop
    let last = performance.now();
    function frame(now) {
      const dt = now - last; // ms
      last = now;

      for (const b of blobs) {
        // Move
        b.cx += b.vx * dt;
        b.cy += b.vy * dt;

        // Bounce on edges (account for current pulsating radius)
        const rPulse = b.rBase * (1 + PULSE_AMPL * Math.sin(b.phase));
        if (b.cx < rPulse && b.vx < 0) b.vx *= -1;
        if (b.cx > WIDTH - rPulse && b.vx > 0) b.vx *= -1;
        if (b.cy < rPulse && b.vy < 0) b.vy *= -1;
        if (b.cy > HEIGHT - rPulse && b.vy > 0) b.vy *= -1;

        // Pulsate
        b.phase += PULSE_SPEED * dt;
        const r = b.rBase * (1 + PULSE_AMPL * Math.sin(b.phase));

        // Color drift
        b.hue = (b.hue + b.hueSpeed * dt) % 360;
        const rgb = hslToRgb(b.hue, b.sat, b.lit);

        // Write to DOM
        b.el.setAttribute('cx', b.cx.toFixed(2));
        b.el.setAttribute('cy', b.cy.toFixed(2));
        b.el.setAttribute('r', r.toFixed(2));
        b.el.style.fill = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);

    // Handle resize: preserve aspect via preserveAspectRatio
    // If you'd like the coordinate space to adapt, recompute viewBox here.

    // Utils
    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }
    function hslToRgb(h, s, l) {
      // h in degrees [0,360), s and l in percent [0,100]
      const hh = ((h % 360) + 360) % 360 / 360;
      const ss = s / 100;
      const ll = l / 100;
      if (ss === 0) {
        const v = Math.round(ll * 255);
        return { r: v, g: v, b: v };
      }
      const q = ll < 0.5 ? ll * (1 + ss) : ll + ss - ll * ss;
      const p = 2 * ll - q;
      const r = Math.round(hue2rgb(p, q, hh + 1/3) * 255);
      const g = Math.round(hue2rgb(p, q, hh) * 255);
      const b = Math.round(hue2rgb(p, q, hh - 1/3) * 255);
      return { r, g, b };
    }
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }
  })();
</script>
</body>
</html>

