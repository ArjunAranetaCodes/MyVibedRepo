<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liquid Glass</title>
<style>
  html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0f14; }
  svg { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
  /* Optional film softness */
  .grain { position: fixed; inset: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.05; mix-blend-mode: soft-light; }
</style>
</head>
<body>
  <!-- Fullscreen SVG with gradient content distorted by turbulence -->
  <svg viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
    <defs>
      <!-- Animated gradient; colors will be shifted via JS (HSL drift) -->
      <linearGradient id="lg" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop id="s0" offset="0%" stop-color="#3a6ff0" />
        <stop id="s1" offset="50%" stop-color="#7ce3ff" />
        <stop id="s2" offset="100%" stop-color="#7bffb1" />
      </linearGradient>

      <!-- Liquid glass filter: noise + displacement + slight blur -->
      <filter id="liquid" x="-20%" y="-20%" width="140%" height="140%">
        <feTurbulence id="turb" type="turbulence" baseFrequency="0.005 0.009" numOctaves="2" seed="2" result="noise" />
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="55" xChannelSelector="R" yChannelSelector="G" />
        <feGaussianBlur stdDeviation="0.8" />
      </filter>
    </defs>

    <!-- Content to distort: a rect filled with our gradient -->
    <g filter="url(#liquid)">
      <rect x="-50" y="-50" width="1100" height="1100" fill="url(#lg)" />
    </g>
  </svg>
  <canvas class="grain"></canvas>

<script>
(function(){
  // Gentle hue drift for gradient stops
  const stops = [
    { el: document.getElementById('s0'), hue: 220, sat: 75, lit: 55, speed: 0.004 },
    { el: document.getElementById('s1'), hue: 190, sat: 80, lit: 62, speed: -0.006 },
    { el: document.getElementById('s2'), hue: 150, sat: 75, lit: 58, speed: 0.005 }
  ];

  // Animate turbulence parameters for organic flow
  const turb = document.getElementById('turb');
  let t = 0;

  let last = performance.now();
  function frame(now){
    const dt = now - last; last = now; t += dt;

    // Update gradient colors
    for (const s of stops){
      s.hue = (s.hue + s.speed * dt) % 360;
      s.el.setAttribute('stop-color', hslToHex(s.hue, s.sat, s.lit));
    }

    // Morph turbulence for a flowing refraction
    const bfX = 0.0045 + 0.0015 * Math.sin(t * 0.0004);
    const bfY = 0.0085 + 0.0020 * Math.cos(t * 0.0003);
    const seed = 2 + Math.sin(t * 0.0002) * 0.5;
    turb.setAttribute('baseFrequency', bfX.toFixed(5) + ' ' + bfY.toFixed(5));
    turb.setAttribute('seed', seed.toFixed(3));

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Subtle animated film grain for texture
  const grain = document.querySelector('canvas.grain');
  const gctx = grain.getContext('2d', { alpha: true });
  function resize(){
    grain.width = innerWidth; grain.height = innerHeight;
  }
  addEventListener('resize', resize); resize();
  function drawGrain(){
    const w = grain.width, h = grain.height;
    const img = gctx.createImageData(w, h);
    const data = img.data;
    for (let i = 0; i < data.length; i += 4){
      const v = 120 + ((Math.random() * 70) | 0); // 120..190
      data[i] = data[i+1] = data[i+2] = v; data[i+3] = 18; // low alpha
    }
    gctx.putImageData(img, 0, 0);
    requestAnimationFrame(drawGrain);
  }
  requestAnimationFrame(drawGrain);

  // Utils
  function hslToHex(h, s, l){
    const a = s * Math.min(l, 100 - l) / 10000;
    const f = n => {
      const k = (n + h / 30) % 12;
      const c = l/100 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return Math.round(255 * c).toString(16).padStart(2, '0');
    };
    return '#' + f(0) + f(8) + f(4);
  }
})();
</script>
</body>
</html>
