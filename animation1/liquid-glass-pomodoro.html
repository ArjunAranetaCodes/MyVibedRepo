<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liquid Glass</title>
<style>
  html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0f14; }
  svg { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
  /* Optional film softness */
  .grain { position: fixed; inset: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.05; mix-blend-mode: soft-light; }
  
  /* Menu styles */
  .menu { position: fixed; top: 14px; left: 14px; z-index: 20; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .menu-button { background: rgba(0, 0, 0, 0.25); border: 1px solid rgba(255, 255, 255, 0.1); color: #e8f6ff; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600; letter-spacing: 0.04em; font-size: 14px; backdrop-filter: blur(10px); }
  .menu-button:hover { background: rgba(0, 0, 0, 0.4); border-color: rgba(255, 255, 255, 0.2); }
  .menu-items { position: absolute; top: 100%; left: 0; margin-top: 4px; background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 4px; min-width: 160px; backdrop-filter: blur(10px); display: none; }
  .menu-items.open { display: block; }
  .menu-item { color: #e8f6ff; padding: 10px 12px; cursor: pointer; border-radius: 6px; display: flex; align-items: center; gap: 8px; font-size: 14px; position: relative; }
  .menu-item:hover { background: rgba(255, 255, 255, 0.1); }
  .menu-item-icon { font-size: 18px; }
  .submenu { position: absolute; left: 100%; top: 0; margin-left: 4px; background: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 12px; min-width: 180px; backdrop-filter: blur(10px); display: none; }
  .menu-item:hover .submenu { display: block; }
  .submenu-label { color: #e8f6ff; font-size: 12px; margin-bottom: 4px; display: block; }
  .submenu-input { width: 100%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 6px 8px; color: #e8f6ff; font-size: 14px; box-sizing: border-box; margin-bottom: 8px; }
  .submenu-input:focus { outline: none; border-color: rgba(255, 255, 255, 0.4); background: rgba(255, 255, 255, 0.15); }
  .submenu-input::placeholder { color: rgba(232, 246, 255, 0.5); }
  .submenu-button { width: 100%; background: rgba(123, 87, 255, 0.6); border: 1px solid rgba(123, 87, 255, 0.8); border-radius: 6px; padding: 8px; color: #e8f6ff; font-size: 14px; font-weight: 600; cursor: pointer; margin-top: 4px; }
  .submenu-button:hover { background: rgba(123, 87, 255, 0.8); }
  
  /* Pause/Play button */
  .timer-controls { position: fixed; top: 70%; left: 50%; transform: translate(-50%, -50%); z-index: 15; }
  .pause-play-btn { width: 80px; height: 80px; border-radius: 50%; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(255, 255, 255, 0.3); color: #ffffff; font-size: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.3s ease; line-height: 1; padding: 0;  padding-bottom: 2px;  text-align: center; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3); }
  .pause-play-btn:hover { background: rgba(0, 0, 0, 0.7); border-color: rgba(255, 255, 255, 0.5); transform: scale(1.1); }
</style>
</head>
<body>
  <div class="menu">
    <button class="menu-button" id="menuButton">‚ò∞ Menu</button>
    <div class="menu-items" id="menuItems">
      <div class="menu-item" onclick="console.log('Menu item 1 clicked')">
        <span class="menu-item-icon">‚è±Ô∏è</span>
        <span>Timer Settings</span>
      </div>
      <div class="menu-item" onclick="console.log('Menu item 2 clicked')">
        <span class="menu-item-icon">‚öôÔ∏è</span>
        <span>Settings</span>
      </div>
      <div class="menu-item">
        <span class="menu-item-icon">üçÖ</span>
        <span>Pomodoro</span>
        <div class="submenu">
          <label class="submenu-label" for="focusInput">Focus (minutes)</label>
          <input type="text" id="focusInput" class="submenu-input" placeholder="25" />
          <label class="submenu-label" for="breakInput">Break (minutes)</label>
          <input type="text" id="breakInput" class="submenu-input" placeholder="5" />
          <button class="submenu-button" id="applyPomodoroBtn">Apply</button>
        </div>
      </div>
    </div>
  </div>
  <div id="timer" style="position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;color:#ffffff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;font-weight:700;letter-spacing:0.06em;background:transparent;z-index:10;line-height:1;-webkit-text-stroke:2px #bbbbbb;text-stroke:2px #bbbbbb;margin-top:-80px;">01:00</div>
  <div class="timer-controls">
    <button class="pause-play-btn" id="pausePlayBtn">‚è∏</button>
  </div>
  <!-- Fullscreen SVG with gradient content distorted by turbulence -->
  <svg viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
    <defs>
      <!-- Animated gradient; colors will be shifted via JS (HSL drift) -->
      <linearGradient id="lg" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop id="s0" offset="0%" stop-color="#3a6ff0" />
        <stop id="s1" offset="50%" stop-color="#7ce3ff" />
        <stop id="s2" offset="100%" stop-color="#7bffb1" />
      </linearGradient>

      <!-- Liquid glass filter: noise + displacement + slight blur -->
      <filter id="liquid" x="-20%" y="-20%" width="140%" height="140%">
        <feTurbulence id="turb" type="turbulence" baseFrequency="0.005 0.009" numOctaves="2" seed="2" result="noise" />
        <feDisplacementMap in="SourceGraphic" in2="noise" scale="55" xChannelSelector="R" yChannelSelector="G" />
        <feGaussianBlur stdDeviation="0.8" />
      </filter>
    </defs>

    <!-- Content to distort: a rect filled with our gradient -->
    <g filter="url(#liquid)">
      <rect x="-50" y="-50" width="1100" height="1100" fill="url(#lg)" />
    </g>
  </svg>
  <canvas class="grain"></canvas>

<script>
(function(){
  // Menu toggle
  const menuButton = document.getElementById('menuButton');
  const menuItems = document.getElementById('menuItems');
  menuButton.addEventListener('click', function(e) {
    e.stopPropagation();
    menuItems.classList.toggle('open');
  });
  document.addEventListener('click', function(e) {
    if (!menuButton.contains(e.target) && !menuItems.contains(e.target)) {
      menuItems.classList.remove('open');
    }
  });

  // Pomodoro settings
  const focusInput = document.getElementById('focusInput');
  const breakInput = document.getElementById('breakInput');
  const applyPomodoroBtn = document.getElementById('applyPomodoroBtn');
  
  const TIMER_MINUTES = 30; // CHANGE THIS to set timer minutes
  const TIMER_SECONDS = 10; // CHANGE THIS to set timer seconds
  let focusDurationMs = 25 * 60 * 1000; // Default 25 minutes
  let breakDurationMs = 5 * 60 * 1000; // Default 5 minutes
  let timerDurationMs = focusDurationMs;
  let isFocusMode = true; // true = focus, false = break
  const TIMER_FONT_SIZE = 300; // px - CHANGE THIS VALUE to modify timer font size
  const timerEl = document.getElementById('timer');
  timerEl.style.fontSize = TIMER_FONT_SIZE + 'px';
  let startTime = performance.now();
  let last = startTime;
  let rafId1 = 0, rafId2 = 0;
  let isPaused = false;
  let pausedElapsed = 0; // Accumulated elapsed time when paused
  let pauseStartTime = 0;
  
  // Pause/Play button
  const pausePlayBtn = document.getElementById('pausePlayBtn');
  pausePlayBtn.addEventListener('click', function() {
    isPaused = !isPaused;
    if (isPaused) {
      // Pause: accumulate elapsed time and stop animation
      const now = performance.now();
      pausedElapsed += now - startTime;
      pauseStartTime = now;
      pausePlayBtn.textContent = '‚ñ∂';
      // Don't stop the frame function, but it will skip timer updates
    } else {
      // Resume: reset startTime to current time
      const now = performance.now();
      startTime = now;
      last = now;
      // If pausedElapsed is 0, we're starting fresh (after auto-pause) - keep it at 0
      // If pausedElapsed > 0, we're resuming a manual pause - keep the accumulated time
      pausePlayBtn.textContent = '‚è∏';
    }
  });
  
  applyPomodoroBtn.addEventListener('click', function() {
    const focusMinutes = parseInt(focusInput.value) || 25;
    const breakMinutes = parseInt(breakInput.value) || 5;
    focusDurationMs = focusMinutes * 60 * 1000;
    breakDurationMs = breakMinutes * 60 * 1000;
    // Start with focus mode
    isFocusMode = true;
    timerDurationMs = focusDurationMs;
    startTime = performance.now();
    last = startTime;
    pausedElapsed = 0; // Reset paused time
    isPaused = false; // Reset pause state
    pausePlayBtn.textContent = '‚è∏'; // Reset button icon
    console.log('Pomodoro settings applied:', { focus: focusMinutes, break: breakMinutes });
    // Restart animation if it had stopped
    if (!rafId1) {
      rafId1 = requestAnimationFrame(frame);
    }
    if (!rafId2) {
      rafId2 = requestAnimationFrame(drawGrain);
    }
    // Close the menu after applying
    menuItems.classList.remove('open');
  });
  // Gentle hue drift for gradient stops with randomized starting colors
  function rand(min, max) { return Math.random() * (max - min) + min; }
  const stops = [
    { el: document.getElementById('s0'), hue: rand(0, 360), sat: 75, lit: 55, speed: 0.004 },
    { el: document.getElementById('s1'), hue: rand(0, 360), sat: 80, lit: 62, speed: -0.006 },
    { el: document.getElementById('s2'), hue: rand(0, 360), sat: 75, lit: 58, speed: 0.005 }
  ];

  // Animate turbulence parameters for organic flow
  const turb = document.getElementById('turb');
  let t = 0;

  function frame(now){
    const dt = now - last; last = now; t += dt;
    
    // Calculate elapsed time (use accumulated paused time)
    let elapsed = isPaused ? pausedElapsed : (now - startTime + pausedElapsed);
    
    // If we just started (pausedElapsed is 0 and not paused), ensure we start from exactly 0
    if (!isPaused && pausedElapsed === 0 && (now - startTime) < 100) {
      // Very early in the timer (first 100ms), ensure clean start
      elapsed = now - startTime;
    }
    
    let remaining = Math.max(0, timerDurationMs - elapsed);
    
    // Timer logic (only when not paused)
    if (!isPaused) {
      // If timer finished, automatically pause and switch to the other mode
      if (remaining <= 0) {
        // Automatically pause
        isPaused = true;
        pausedElapsed = 0; // Reset for new timer
        pausePlayBtn.textContent = '‚ñ∂';
        
        // Switch to the other mode
        isFocusMode = !isFocusMode;
        timerDurationMs = isFocusMode ? focusDurationMs : breakDurationMs;
        startTime = performance.now();
        last = startTime;
        remaining = timerDurationMs; // Show full time for next timer, but paused
        console.log('Timer finished. Auto-paused. Next mode:', isFocusMode ? 'Focus' : 'Break');
      }
    }
    
    // Always update timer display - use floor instead of ceil to prevent flicker
    const totalSeconds = Math.floor(remaining / 1000);
    const clamped = Math.max(0, totalSeconds);
    const mm = Math.floor(clamped / 60);
    const ss = clamped % 60;
    timerEl.textContent = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;

    // Update gradient colors (always animate)
    for (const s of stops){
      s.hue = (s.hue + s.speed * dt) % 360;
      s.el.setAttribute('stop-color', hslToHex(s.hue, s.sat, s.lit));
    }

    // Morph turbulence for a flowing refraction (always animate)
    const bfX = 0.0045 + 0.0015 * Math.sin(t * 0.0004);
    const bfY = 0.0085 + 0.0020 * Math.cos(t * 0.0003);
    const seed = 2 + Math.sin(t * 0.0002) * 0.5;
    turb.setAttribute('baseFrequency', bfX.toFixed(5) + ' ' + bfY.toFixed(5));
    turb.setAttribute('seed', seed.toFixed(3));

    // Always continue the animation
    rafId1 = requestAnimationFrame(frame);
  }
  rafId1 = requestAnimationFrame(frame);

  // Subtle animated film grain for texture
  const grain = document.querySelector('canvas.grain');
  const gctx = grain.getContext('2d', { alpha: true });
  function resize(){
    grain.width = innerWidth; grain.height = innerHeight;
  }
  addEventListener('resize', resize); resize();
  function drawGrain(){
    const w = grain.width, h = grain.height;
    const img = gctx.createImageData(w, h);
    const data = img.data;
    for (let i = 0; i < data.length; i += 4){
      const v = 120 + ((Math.random() * 70) | 0); // 120..190
      data[i] = data[i+1] = data[i+2] = v; data[i+3] = 18; // low alpha
    }
    gctx.putImageData(img, 0, 0);
    // Always continue the grain animation
    rafId2 = requestAnimationFrame(drawGrain);
  }
  rafId2 = requestAnimationFrame(drawGrain);

  // Utils
  function hslToHex(h, s, l){
    const a = s * Math.min(l, 100 - l) / 10000;
    const f = n => {
      const k = (n + h / 30) % 12;
      const c = l/100 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return Math.round(255 * c).toString(16).padStart(2, '0');
    };
    return '#' + f(0) + f(8) + f(4);
  }
  
  // Initialize gradient with random colors
  for (const s of stops) {
    s.el.setAttribute('stop-color', hslToHex(s.hue, s.sat, s.lit));
  }
})();
</script>
</body>
</html>

